# Disaster Rescue Task

災害救助シナリオにおける救助車両の協調戦略を進化させるタスクです。

## 概要

このタスクは、日本のような災害大国における緊急時の救助計画作成を支援することを目的としています。複数の救助車両が協力して、様々な深刻度レベルを持つ被災者を効率的に救助する戦略を進化させます。

## シナリオ設定

### 環境
- **グリッドサイズ**: 10×10のマス目
- **障害物**: 10箇所（通行不可）
- **救助対象（ターゲット）**: 15箇所
  - 各ターゲットには深刻度レベル（1〜10）が付与
  - 深刻度が高いほど緊急性が高い
- **救助車両**: 5台
  - 各車両はマス目を1ステップずつ移動
  - ターゲットのいるマスに到達すると救助完了

### 制約
- 救助車両は障害物を避けて移動する必要がある
- 複数の車両が同じターゲットを同時に目指すのは非効率
- 最大500ステップ以内に全員を救助することが望ましい

## 進化対象の関数

`select_target` 関数が進化の対象です：

```python
def select_target(
    vehicle_id: int,
    vehicle_pos: Tuple[int, int],
    unrescued_targets: List[Dict],
    other_vehicles: List[Dict],
    grid_size: Tuple[int, int],
    obstacles: List[Tuple[int, int]],
) -> Optional[int]:
```

### 入力パラメータ

- `vehicle_id`: 現在の車両のID（0から始まる整数）
- `vehicle_pos`: 車両の現在位置 `(row, col)`
- `unrescued_targets`: 未救助のターゲットのリスト
  - `id`: ターゲットID
  - `pos`: 位置 `(row, col)`
  - `severity`: 深刻度レベル（1〜10）
- `other_vehicles`: 他の救助車両の情報リスト
  - `id`: 車両ID
  - `pos`: 位置 `(row, col)`
  - `target_id`: 現在目指しているターゲットID（またはNone）
- `grid_size`: グリッドのサイズ `(rows, cols)`
- `obstacles`: 障害物の位置リスト `[(row, col), ...]`

### 返り値

- 目指すべきターゲットのID（整数）
- ターゲットがない場合は `None`

## 評価指標

### 複数シナリオでの評価

過適合を防ぐため、複数の異なるシナリオで評価を行います：

1. **ランダムシナリオ（×2）**: 完全にランダムな配置
2. **クラスター型ターゲット**: ターゲットが四隅に集中
3. **分離型ターゲット**: ターゲットが左右に分離
4. **迷路型**: 障害物が迷路パターンを形成（グリッドサイズに基づいた自動配置）
5. **密集型車両**: 救助車両が一箇所に密集してスタート
6. **対角壁型**: 対角線上の壁がマップを二分割（グリッドサイズに基づいた自動配置）

最終スコアは全シナリオの平均スコアです。

**注意**: 迷路型と対角壁型のシナリオでは、`num_obstacles`パラメータは無視され、グリッドサイズに応じた理想的な障害物パターンが自動生成されます。

### 動的災害モード（新機能）

通常モードに加えて、**動的災害モード**が利用可能になりました。このモードでは：

- **時間経過とともにターゲットが追加**: 新たな被災者が発見され続ける
- **障害物も動的に増加**: 余震や二次災害により新たな障害物が出現
- **ポアソン分布に従った確率的追加**: 実際の災害現場のような不確実性を再現
- **終了条件**: 全てのターゲット（動的に追加されたものを含む）を救助するまで継続

#### パラメータ

- `--dynamic`: 動的モードを有効化
- `--target_spawn_rate`: ターゲット追加率（ポアソン分布のλ、デフォルト: 0.05）
- `--obstacle_spawn_rate`: 障害物追加率（ポアソン分布のλ、デフォルト: 0.03）

#### スコア計算の調整

動的モードでは、追加されたターゲットの出現時刻を考慮してスコアを計算します：
- 初期ターゲット: 通常通りステップ1からの時間でスコア計算
- 動的追加ターゲット: 出現ステップからの時間でスコア計算（公平性を保つため）

### シナリオの特徴

#### 極端なケース

- **クラスター型**: 遠く離れたターゲットへの効率的な割り当てが必要
- **分離型**: 車両を左右のグループに分けるべきか判断が必要
- **迷路型**: 複雑な障害物パターンによる大きな迂回が頻発。垂直・水平の壁が入り組んだ構造
- **密集型車両**: 車両同士の衝突回避と効率的な分散が課題
- **対角壁型**: 太い対角壁とボトルネックにより、壁を迂回する最短経路の選択が重要

### シミュレーションの動作

各ステップで以下が実行されます：

1. **動的要素の追加**（動的モードのみ）: ポアソン分布に従ってターゲットと障害物を追加
2. **全車両の位置を記録**: すべての車両の現在位置を保存
3. **戦略関数の並列実行**: 各車両が独立に次のターゲットを決定
   - 全車両が同じ未救助ターゲットリストを参照
   - 他の車両の位置・ターゲット情報も参照可能
4. **一斉移動**: 全車両が同時に1マス移動
5. **救助チェック**: ターゲット位置に到達した車両は救助を実行

この方式により、より現実的な同時行動シミュレーションが可能になります。

### スコア計算

救助スコアは以下の式で計算されます：

```
weighted_score = Σ(severity × log(max_steps + 2 - rescue_time))
```

- `severity`: ターゲットの深刻度（1〜10）
- `rescue_time`: 救助完了ステップ
- **対数スケール**: 早期救助の価値を高く評価しつつ、遅延の影響は逓減

#### 対数ペナルティの効果

線形ペナルティと比較して：
- 5秒と10秒の差: 大きな違い
- 100秒と105秒の差: 小さな違い

これにより、初動の速さがより重要になります。

### 正規化スコア

最終的なスコアは**0〜1の範囲**に正規化されます：

```
normalized_score = weighted_score / max_possible_score
```

`max_possible_score`は全ターゲットをステップ1で救助した場合の理論上最高スコアです。

## 使用方法

### 1. 初期プログラムの評価

```bash
cd examples/disaster_rescue
python evaluate.py
```

デフォルトで7つのシナリオで評価され、可視化を有効にすると可視化GIFが生成されます。

#### 通常モード（静的シナリオ）

```bash
# 可視化を有効化
python evaluate.py --visualize

# シナリオ数を変更
python evaluate.py --num_scenarios 10
```

#### 動的災害モード

時間経過とともにターゲットと障害物が追加されるモードを有効化：

```bash
# 基本的な動的モード
python evaluate.py --dynamic

# 可視化付き動的モード
python evaluate.py --dynamic --visualize

# 追加率をカスタマイズ（より頻繁に要素を追加）
python evaluate.py --dynamic --target_spawn_rate 0.1 --obstacle_spawn_rate 0.05

# 少ない追加率でテスト
python evaluate.py --dynamic --target_spawn_rate 0.02 --obstacle_spawn_rate 0.01
```

**パラメータ説明**:
- `--dynamic`: 動的モードを有効化
- `--target_spawn_rate`: 1ステップあたりのターゲット追加期待値（デフォルト: 0.05）
- `--obstacle_spawn_rate`: 1ステップあたりの障害物追加期待値（デフォルト: 0.03）

**例**: `--target_spawn_rate 0.05`の場合、平均して20ステップに1回新しいターゲットが追加されます（ポアソン分布）。

### 2. 進化実験の実行

```bash
python run_evo.py
```

進化の進捗は `results_disaster_rescue/` ディレクトリに保存されます。

### 3. 結果の確認

評価結果には以下が含まれます：

- `metrics.json`: 評価メトリクス（全シナリオの平均スコア）
- `correct.json`: 検証結果
- `scenarios_detail.json`: 各シナリオの詳細結果
- `rescue_log_scenario0.json`: 最初のシナリオの詳細な救助ログ
- `simulation.gif`: 最初のシナリオの可視化アニメーション

#### メトリクスの読み方

```json
{
  "combined_score": 0.7458,  // 全シナリオの平均正規化スコア（0-1）
  "public": {
    "num_scenarios": 7,       // 評価シナリオ数
    "num_successful": 7,      // 成功したシナリオ数
    "avg_total_rescued": "15.00",  // 平均救助数
    "avg_total_steps": "15.57",    // 平均ステップ数
    "all_rescued_rate": "7/7"      // 全員救助達成率
  },
  "private": {
    "avg_normalized_score": 0.7458,   // 平均スコア
    "min_normalized_score": 0.7040,   // 最低スコア
    "max_normalized_score": 0.7890,   // 最高スコア
    "scenario_scores": [...]          // 各シナリオの詳細
  }
}
```

#### 可視化について

`simulation.gif`には以下が表示されます：

- **ターゲット（円）**: 深刻度に応じて色分け（黄色→赤、数字は深刻度）
- **救助車両（四角）**: 目指しているターゲットと同じ色で表示
- **矢印**: 各車両が向かっているターゲットへの方向
- **障害物（灰色の四角）**: 通行不可エリア
- **救助済みターゲット（灰色の円にチェックマーク）**: 既に救助完了

この可視化により、救助車両の協調動作や戦略の良し悪しが一目で分かります。

## 戦略のヒント

効果的な救助戦略の例：

### 基本戦略
1. **優先度ベース**: 深刻度の高いターゲットを優先
2. **近接性ベース**: 最も近いターゲットを選択
3. **ハイブリッド**: 深刻度と距離のバランス

### 高度な戦略
1. **クラスタリング**: エリアごとに車両を割り当て
2. **動的再割り当て**: 状況に応じて目標を変更
3. **先読み**: 次の救助も考慮した選択
4. **協調回避**: 他車両との競合を避ける
5. **経路最適化**: 障害物を考慮した効率的な経路

## ファイル構成

```
disaster_rescue/
├── README.md           # このファイル
├── __init__.py         # パッケージ初期化
├── initial.py          # 初期戦略（単純な最近接法）
├── evaluate.py         # 評価スクリプト（シミュレーション実行と可視化）
├── scenarios.py        # シナリオ生成モジュール（7種類のシナリオタイプ）
├── run_evo.py         # 進化実験スクリプト
└── results/           # 実行結果（自動生成）
    ├── metrics.json
    ├── correct.json
    ├── scenarios_detail.json
    ├── rescue_log_scenario0.json
    └── simulation_*.gif  # 可視化アニメーション（visualize有効時）
```

### モジュール詳細

#### `scenarios.py`
シナリオ生成を独立したモジュールとして切り出しており、以下の7種類のシナリオジェネレーター関数を提供：

- `generate_random_scenario()`: 完全ランダム配置
- `generate_clustered_targets_scenario()`: ターゲットを4隅にクラスタリング
- `generate_split_targets_scenario()`: ターゲットを左右に分割配置
- `generate_maze_scenario()`: 迷路のような障害物パターン（グリッドサイズに応じて自動生成、約20個の障害物）
- `generate_clustered_vehicles_scenario()`: 車両を1箇所に集中配置
- `generate_diagonal_wall_scenario()`: 対角線の壁で領域分割（グリッドサイズに応じて自動生成、約20個の障害物）

各関数は`(targets, vehicles, obstacles)`のタプルを返し、`RescueSimulator`クラスで使用されます。

**注意**: `generate_maze_scenario()`と`generate_diagonal_wall_scenario()`は、`num_obstacles`パラメータを無視し、グリッドサイズに基づいた理想的な障害物配置を自動生成します。これにより、より挑戦的で構造化されたシナリオが作成されます。

#### `evaluate.py`
- `RescueSimulator`クラス: シミュレーション実行、BFS経路探索、可視化機能
- `validate_rescue_result()`: 結果の検証
- `get_rescue_kwargs()`: シナリオタイプの選択
- `aggregate_rescue_metrics()`: 複数シナリオの集計

## 期待される改善

進化により以下の改善が期待されます：

1. **救助時間の短縮**: より効率的な割り当てにより全体の救助時間を削減
2. **高優先度の早期救助**: 深刻度の高いターゲットを優先的に救助
3. **車両間の協調**: 重複を避け、効率的な分担を実現
4. **適応的戦略**: 様々なシナリオ（クラスター、分離、迷路など）に対応できる柔軟な戦略
5. **ロバスト性向上**: 極端な配置でも安定したパフォーマンス

## 注意事項

- シミュレーションは決定的（固定シード）なので、同じプログラムは常に同じ結果を生成します
- 最大500ステップで評価が終了します
- 関数が例外を投げた場合、そのプログラムは無効として扱われます

## 今後の拡張案

- より大きなグリッドサイズ
- 動的な障害物（時間経過で変化）
- 救助能力の異なる車両タイプ
- 複数のシナリオでの評価
- リアルタイム制約（計算時間制限）

## ライセンス

このプロジェクトはShinkaEvolveの一部として提供されています。
